{\rtf1\ansi\ansicpg1252\cocoartf2576
\cocoatextscaling0\cocoaplatform0{\fonttbl\f0\fswiss\fcharset0 Helvetica;\f1\froman\fcharset0 Times-Roman;\f2\froman\fcharset0 Times-BoldItalic;
\f3\froman\fcharset0 Times-Bold;}
{\colortbl;\red255\green255\blue255;\red0\green0\blue0;}
{\*\expandedcolortbl;;\cssrgb\c0\c0\c0;}
\margl1440\margr1440\vieww38200\viewh18500\viewkind0
\pard\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640\pardirnatural\partightenfactor0

\f0\fs24 \cf0 2.1-1: 
\f1\fs29\fsmilli14667 \cf2 \expnd0\expndtw0\kerning0
Using Figure 2.2 as a model, illustrate the operation of I
\fs24 NSERTION
\fs29\fsmilli14667 -S
\fs24 ORT 
\fs29\fsmilli14667 on the array A =[31,41,59,26,41,58].\
	-int[] insertionSort(int[] nums)\{\
			for(int i=0;i<nums.length-1;i++)\{\
				for(int j=i+1;j<nums.length;j++)\{\
					if(nums[i]>nums[j])\{\
						int temp = nums[i];\
						nums[i] = nums[j];\
						nums[j] = temp;\
					\}\
				\}\
			\}\
			return nums;\
		\}\
2.1-2: Rewrite the I
\fs24 NSERTION
\fs29\fsmilli14667 -S
\fs24 ORT 
\fs29\fsmilli14667 procedure to sort into nonincreasing instead of non- decreasing order. 
\fs24 \

\fs29\fsmilli14667 	- int[] insertionSort(int[] nums, boolean isAscending)\{\
			for(int i=0;i<nums.length-1;i++)\{\
				for(int j=i+1;j<nums.length;j++)\{\
					if(nums[i]>nums[j])\{\
						int temp = nums[i];\
						nums[i] = nums[j];\
						nums[j] = temp;\
					\}\
				\}\
			\}\
			if(!isAscending)\{\
			    int left = 0;\
			    int right = nums.length-1;\
			    while(left<right)\{\
			        int temp = nums[left];\
			        nums[left] = nums[right];\
			        nums[right] = temp;\
			        left++;right--;\
			    \}\
			\}\
			return nums;\
		\}\
2.1-3 Consider the 
\f2\i\b searching problem
\f1\i0\b0 : 
\fs24 \
\pard\pardeftab720\sa240\partightenfactor0

\f3\b\fs29\fsmilli14667 \cf2 Input: 
\f1\b0 A sequence of n numbers A D ha
\fs18\fsmilli9333 \dn6 1
\fs29\fsmilli14667 \up0 ;a
\fs18\fsmilli9333 \dn6 2
\fs29\fsmilli14667 \up0 ;:::;a
\fs18\fsmilli9333 \dn6 n
\fs29\fsmilli14667 \up0 i and a value 
\f0 \uc0\u56319 \u56321 
\f1 .\uc0\u8232 
\f3\b Output: 
\f1\b0 An index i such that 
\f0 \uc0\u56319 \u56321 
\f1  D A\'8ci
\f0 \uc0\u56319 \u56320 
\f1  or the special value 
\fs24 NIL 
\fs29\fsmilli14667 if 
\f0 \uc0\u56319 \u56321 
\f1  does not 
\fs24 \

\fs29\fsmilli14667 appear in A. 
\fs24 \

\fs29\fsmilli14667 Write pseudocode for 
\f2\i\b linear search
\f1\i0\b0 , which scans through the sequence, looking for 
\f0 \uc0\u56319 \u56321 
\f1 . Using a loop invariant, prove that your algorithm is correct. Make sure that your loop invariant fulfills the three necessary properties. 
\fs24 \
	- The base case will be that for any number in the array, the return will be either nil, or the index at which the value is found.\
		for int 0 \'85 nums length\
			return nums[int] if int == t;\
		default: return nil; \
	Complexity: O(n) we can do it lg(n) but the array must be sorted in advance.\
2.1-4 
\fs29\fsmilli14667 Consider the problem of adding two n-bit binary integers, stored in two n-element arrays A and B. The sum of the two integers should be stored in binary form in 
\fs24 \

\fs29\fsmilli14667 an .n C 1/-element array C . State the problem formally and write pseudocode for adding the two integers. \
	if A.length!-B.length return nil;\
		for int I<N\
			C[I] = A[I]+B[I];\

\fs24 	RETURN C;\
\
\
}